# Intro to julia

$\def\I{{\rm i}}$

Reference: [The Julia Documentation](https://docs.julialang.org)

This lecture gives an overview of Julia. [The Juliaâ€“Matlabâ€“Python Cheatsheet](https://cheatsheets.quantecon.org)
Is a valuable resource for translating between the three languages.

## Integers

Julia uses a math-like syntax for manipulating integers:
```julia
1 + 1 # Addition
```
```julia
2 * 3 # Multiplication
```
```julia
x = 5; # semicolon is optional but supresses output if used in last line
x^2 # Powers
```
In Julia everything has a type. This is similar in spirit to 
a class in Python, but much more lightweight. 
An integer defaults to type `Int`, 
which is either 32-bit (`Int32`) or 64-bit (`Int64`) depending
on the processor of the machine. 
These are "primative type", instances of the type are stored in memory as 
a fixed length sequence of bits.
 
We can see the bits using the function `bitstring`:
```julia
bitstring(1)
```
The first bit is a sign bit: if it is equal to `1` the 
integer is negative
```julia
bitstring(-1)
```

This may be counter-intuitive (did you expect `1000â€¦00001`?)
but has the nice benefit that addition behaves the same for 
positive integers and negative integers.  

`Int` follows [modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic),
that is, it is equivalent to the ring of integers modulo `2^p` where `p` is `32` or `64`. 
Thus for $p = 64$ we are interpreting
$2^{32} \mod 2^{64}$ through $(2^{64}-1) \mod 2^{64}$ as negative numbers but 
they are not treated specially.


**Example (addition)**
Consider `(-1) + 1`. They behave like modular arithmetic so we have:
$$
(-1 \mod 2^p) + (1 \mod 2^p) = (2^p-1 \mod 2^p) + (1 \mod 2^p) = 2^p \mod 2^p = 0 \mod 2^p
$$

**Example (multiplication)**
Consider `(-2) * 2`. We have:
$$
(-2 \mod 2^p) * (2 \mod 2^p) = (2^p-2 \mod 2^p) * (2 \mod 2^p) = (2^(p+1)-4 \mod 2^p) = -4 \mod 2^p
$$




We can find the largest and smallest instances of a type using `typemax` and `typemin`:
```julia
typemax(Int32)
```
```julia
bitstring(typemax(Int32))
```
```julia
typemin(Int32)
```
```julia
bitstring(typemin(Int32))
```
Since `Int64` behaves like modulo arithmetic we do not "overflow" but rather wrap around:
```julia
typemax(Int64) + 1 # returns typemin(Int32)
```


There are other primitive integer types: `Int8` and `Int16` are like `Int32` and `Int64` but with
fewer bits. `UInt8`, `UInt16`, `UInt32`, and `UInt64` are unsigned integers, e.g., we do not interpret
the number as negative if the first bit is `1`. A non-primitive type is `BigInt` which allows arbitrary length
integers, which we can create using `big`:
```julia
x = typemax(Int64) + big(1) # Too big to be an `Int64`
```
Note in this case it automatically promotes an `Int64` to a `BigInt`. 
We can create very large numbers using `BigInt`:
```julia
x^100
```
Note the number of bits is not fixed so it is possible to run out of memory if a number is 
astronomically large: go ahead and try `x^x` (at your own risk).

In addition to `+`, `-`, and `*` we have integer division `Ã·`, which rounds down:
```julia
5 Ã· 2 # equivalent to div(5,2)
```
Standard division `/` (or `\` for division on the right) creates a floating point number, which will be discussed in
the next chapter:
```julia
5 / 2 # alternatively 2 \ 5
```

We can also create rational numbers using `//`:
```julia
(1//2) + (3//4)
```
Rational arithmetic often leads to overflow so it
is often best to combine `big` with rationals:
```julia
102324//132413023 + 23434545//4243061 + 23434545//42430534435
big(102324)//132413023 + 23434545//4243061 + 23434545//42430534435
```

## String

We have seen that `bitstring` returns a string of bits.
Strings can be created with quotation marks
```julia
str="hello world ðŸ˜€"
```
We can access characters of a string with brackets:
```julia
str[1],str[13]
```
Each character is a bit type, in this case using 32 bits/8 bytes:
```julia
typeof(str[6]), length(bitstring(str[6]))
```
Strings are not bit types, but rather point to the start of sequence 
of `Char` in memory.  In this case, there are $32*13=416$ bits/52 
bytes in memory.

Strings are _immutable_: once created they cannot be changed.
But a new string can be created that modifies an existing string:
```julia

```


## Parsing strings

We can use the command `parse` to turn a string into an integer:
```julia
parse(Int, "123")
```
We can specify base 2 as an optional argument. If we are specifying
bits its safer to parse as a `UInt32`, otherwise the first bit
is not recognised as a sign:
```julia
bts = "11110000100111111001100110001010"
x = parse(UInt32, bts; base=2)
```
The function `reinterpret` allows us to reinterpret the resulting 
sequence of 32 bits as a different type. For example, we can reinterpret
as an `Int32` in which case the first bit is taken to be the sign bit
and we get a negative number:
```julia
reinterpret(Int32, x)
```
We can also reinterpret as a `Char`:
```julia
reinterpret(Char, x)
```
We will use `parse` and `reinterpret` in problem sheets and the midterm exam
as it allows one to easily manipulate bits. This is not actually how one should
do it as it is slow.

## Bitwise operations (advanced)

In practice, one should manipulate bits using bitwise operations. 
These will not be required in this course and are not examinable, but
are valuable to know if you have a career involving high performance computing.
The `p << k` shifts the bits of `p` to the left `k` times inserting zeros, 
while `p >> k` shifts to the right:
```julia
println(bitstring(23));
println(bitstring(23 << 2));
println(bitstring(23 >> 2));
```
The operations `&`, `|` and `âŠ»` do bitwise and, or, and xor.

## Vectors, Matrices, and Arrays

We can create a vector using brackets:
```julia
v = [11, 24, 32]
```
Like a string, elements are accessed via brackets. Julia
uses 1-based indexing (like Matlab and Mathematica, unlike
Python and C which use 0-based indexing):
```julia
v[1], v[3]
```
Accessing outside the range gives an error:
```julia
v[4]
```
Vectors can be made with different types, for example, 
here is a vector of three 8-bit integers:
```julia
v = [Int8(11), Int8(24), Int8(32)]
```
Just like strings, Vectors are not bit types, 
but rather point to the start of sequence of the corresponding type.  
In this last case, there are $3*8=24$ bits/3 bytes in memory.

The easiest way to create a vector is to use `zeros` to create a zero `Vector` 
and then modify its entries:
```julia
v=zeros(Int, 5)
v[2]=3
v
```
Note: we can't assign a floating point number to an integer vector:
```julia
v[2] = 3.5
```
We can also create vectors with `ones` (a vector of all ones), `rand` (a vector of random numbers between `0` and `1`)
and `randn` (a vector of samples of normal distributed quasi-random numbers).

When the elements are of different types, they are mapped to a type that can represent every entry.  
For example, here we input a list of one `Int32` followed by three `Int64`s, which are automatically converted to `Int64`: 
```julia
[Int32(1), 2, 3, 4]
```
In the event that the types cannot automatically be converted, it defaults to an `Any` vector.  
This is bad performancewise as it does not know how many bits each element will need, so should be avoided.
```julia
[1.0,1,"1"]
```
We can also specify the type of the Vector explicitly by writing the desired type before the first bracket:
```julia
Int32[1,2,3]
```
We can also create an array using brackets, a formula and a `for` command:
```julia
[k^2 for k=1:5]
```


Matrices are created similar to vectors, but by specifying two dimensions instead of one.  
Again, the simplest way is to `zeros` to create a matrix of all zeros:
```julia
zeros(Int, 5, 5) # creates a 5x5 matrix of Int zeros
```
We can also create matrices by hand.  Here, spaces delimit the columns and semicolons delimit the rows:
```julia
[1 2; 3 4; 5 6]
```
We can also create matrices using brackets, a formula, and a `for` command:
```julia
[k^2+j for k=1:5, j=1:5]
```
Matrices are really Vectors in disguise.  They are still stored in memory in a sequence of addresses.  
We can see the underlying vector using the `vec` command:
```julia
M = [1 2; 3 4; 5 6]
vec(M)
```
The only difference between matrices and vectors from the computers perspective is that they have a `size` which changes the interpretation of whats stored in memory:
```julia
size(M)
```
Matrices can be manipulated easily on a computer.  We can easily take determinants:
```julia
det(M)
```
Or multiply:
```julia
[1 2; 3 4] * [4 5; 6 7]
```
If you use `.*`, it does entrywise multiplication:
```julia
[1 2; 3 4] .* [4 5; 6 7]
```
Vectors are thought of as column vectors, and so `*` is not defined:
```julia
a = [1, 2, 3]
b = [4, 5, 6]
a*b
```
Whereas entry-wise multiplication with `.*` works fine (try it!).

Transposing a Vector gives a row vector, which is represented by a `1 x n` matrix:
```julia
a'
```
Thus we can do dot products as follows:
```julia
a' * b
```

One important note: a vector is not the same as an `n x 1` matrix.



## Types


Julia has two different kinds of types: bittypes (like `Int64`, `Int32`, `UInt32` and `Char`) and composite types.  

Here is an example of an inbuilt composite type representing complex numbers, for example, 
$$x = 1+\I$$


```julia
x = 1+2im
```

```julia
```

```julia
```
```julia
```
```julia
```