# Week 1

This problem sheet tests the representation of numbers on the computer, using
modular arithmetic. We also use floating point rounding modes to implement 
interval arithmetic, and thereby
produce rigorous bounds on the exponential.

```julia
using ColorBitstring, SetRounding
```

## 1. Binary representation


**Problem 1.1** What is the binary representations of $1/5$?

**SOLUTION**

Note that
```julia
printbits(1/5)
```
Hence we  show that
$$
\begin{align*}
(0.00110011001100…)_2 &= (2^{-3} + 2^{-4})(1.00010001000…)_2 =  (2^{-3} + 2^{-4}) \sum_{k=0}^∞ {1 \over 16^k} \\
&= {2^{-3} + 2^{-4} \over 1 - {1\over 2^4}} = {3 \over 15} = {1 \over 5}
\end{align*}
$$





**Problem 1.2** What is $\pi$ to 5 binary places? Hint: recall that $\pi \approx  3.14$.

**SOLUTION**
Note that
```julia
3 + 1/8  + 1/64
```
which has the binary representation
$$
(11.001001)_2
$$
Indeed:
```julia
printbits(Float16(π))
```

## 2. Integers

**Problem 2.1** With 8-bit signed integers, find the bits for the following:
$$
10, 120, -10
$$
**SOLUTION**
We can find the binary digits by repeatedly subtracting the largest power of 2 less than a number
until we reach 0, e.g.:
$$
10 -2^3 - 2 = 0
$$
implies
$$
10 = (101)_2
$$
Thus the bits are:
```julia
printlnbits(Int8(10))
```
Similarly,
$$
120 = 2^6 + 2^5 + 2^4 + 2^3 = (1111000)_2
$$
Thus the bits are:
```julia
printlnbits(Int8(120))
```
For negative numbers we perform the same trick but adding $2^p$ to make it positive, e.g.,
$$
-10 = 2^8 - 10 ({\rm mod 2^8}) = 246 = 2^7 + 2^6 + 2^5 + 2^4 + 2^2 + 2 = (11110110)_2
$$
This the bits are:
```julia
printlnbits(Int8(-10))
```


**Problem 2.2** What will `Int8(120) + Int8(10)` return?

**SOLUTION**
It will return
$$
130 ({\rm mod\ } 2^8) = -126 ({\rm mod\ } 2^8)
$$
```julia
Int8(120) + Int8(10)
```

## 3. Floating point numbers

**Problem 3.1** What is the single precision $F_{32}$ (`Float32`) floating point representation for the following: 
$$
2, 30, 31, 32, 33, 23/4, (23/4)\times 2^{100}, (23/4)\times 2^{−100}, (23/4)\times2^{−135}
$$
When rounded to nearest, what are the single precision bits of $1/5$?
Check your answers using `printbits`.


**SOLUTION**
Recall that we have `σ,Q,S = 127,8,23`. Thus we write
$$
2 = 2^{128-127} * (1.00000000000000000000000)_2
$$
The exponent bits are those of
$$
128 = 2^7 = (10000000)_2
$$
Hence we get
```julia
printlnbits(2f0)
```

```julia
printlnbits(30f0)
printlnbits(31f0)
printlnbits(32f0)
printlnbits(33f0)
printlnbits(23f0/4)
printlnbits(2f0^100)
printlnbits(23f0/4 * 2f0^(-100))
printlnbits(23f0/4 * 2f0^(-135))
printlnbits(1f0/5)
```



**Problem 3.2** Let $m(y) = \min\{x \in F_{32} : x > y \}$ be the smallest single precision number
greater than $y$. What is $m(2) - 2$ and $m(1024) - 1024$? Check your answer using the `nextfloat`
command.
```julia
nextfloat(2f0) - 2, nextfloat(1024f0) - 1024
```

**SOLUTION**

## 4. Arithmetic


**Problem 4.1** Suppose $x = 1.25$ and consider 16-bit floating point arithmetic (`Float16`). 
What is the error in approximating $x$ by the nearest float point number ${\rm fl}(x)$?
What is the error in approximating $2x$, $x/2$, $x + 2$ and $x - 2$ by $2 \otimes x$, $x \oslash 2$, $x \oplus 2$ and $x \ominus 2$?
For what floating point numbers is $x \oslash 2 \neq x/2$ and $x \oplus 2 \neq x + 2$?

**Problem 4.2** Explain the following:
```julia
x = 10.0^100
x + 1 == x
```
What is the largest floating point number such that `x + 1 ≠ x`?

**Problem 4.3** What are the exact bits for $1/5$, $1/5 + 1$, $(1/5)^2$, and $(1.1-1)/0.1$  computed
using  half-precision (`Float16`) (using
default rounding)?

**SOLUTION**



**Problem 4.4** Find a bound on the floating point error for the following
$$
\begin{align*}
(1.1 ⊖ 1) &⊘ 0.1 \\
(1.1 ⊕ 1.2) &⊗ 1.3
\end{align*}
$$
How does your bound compare with the true error?



## 5. Interval arithmetic



**Problem 5.1** Complete the following function which computes the first `n` terms of the Taylor series of $\exp(x)$, that is,
$$
\sum_{k=0}^n {x^k \over k!}
$$
using only algebraic operations (e.g. do not call `factorial(k)`).

```julia
function exp_t(x, n)
    ret = one(x) # 1 of same type as x
    s = one(x)
    for k = 1:n
        s = s/k * x
        ret = ret + s
    end
    ret
end
```

The following problems consider implementation of interval arithmetic for
proving precise bounds on arithmetic operations. That is recall the set operations
$$
A + B = \{x + y : x \in A, y \in B\}, AB = \{xy : x \in A, y \in B\}.
$$
We want to implement floating point variants such that, for $S = [a,b] + [c,d]$
and $P = [a,b] * [c,d]$,
$$
\begin{align*}
[a,b] \oplus [c,d] &:= [{\rm fl}^{\rm down}(\min S), {\rm fl}^{\rm up}(\max S)] \\
[a,b] \oplus [c,d] &:= [{\rm fl}^{\rm down}(\min P), {\rm fl}^{\rm up}(\max P)]
\end{align*}
$$
This guarantees $[a,b] + [c,d] \subset [a,b] \oplus [c,d]$, i.e., if $x \in [a,b]$ and
$y \in [c,d]$ then $x +y \in [a,b] \oplus [c,d]$, and we thereby have rigorous bounds.


**Problem 5.2** For intervals $A = [a,b]$ and $B = [c,d]$ such that $0 \notin A,B$
 and integer $n \neq 0$, 
deduce formulas for the minimum and maximum of $A/n$, $A+B$ and $AB$.

**Solution**

$$
\begin{align*}
{A \over n} &= \begin{cases}
[a/n,b/n] & n > 0 \\
[b/n,a/n] & n < 0
\end{cases},\\
A + B &= [a + c, b + d] \\
AB &= \begin{cases}
[cd,ab]& a,b,c,d < 0 \\
[ad,bc]& a,b < 0 \hbox{ and } c,d >0 \\
[bc,ad]& a,b > 0 \hbox{ and } c,d  < 0 \\
[ab,cd]& a,b,c,d >> 0
\end{cases}
\end{align*}
$$




**Problem 5.3** Use the formulae from Problem 5.2 to complete the following definition:


```julia
struct Interval{T}
    a::T
    b::T
end

import Base: *, +, -, /, one, in
one(x::Interval) = Interval(one(x.a), one(x.b))
in(x, y::Interval) = y.a ≤ x ≤ y.b

function /(x::Interval, n::Integer)
    T = typeof(x.a)
    if iszero(n)
        error("Dividing by zero not support")
    end
    a = setrounding(T, RoundDown) do
        # TODO: lower bound
        ## SOLUTION
        if n > 0
            x.a / n
        else
            x.b / n
        end
        ## END
    end
    b = setrounding(T, RoundUp) do
        # TODO: upper bound
        ## SOLUTION
        if n > 0
            x.b / n
        else
            x.a / n
        end
        ## END
    end
    Interval(a, b)
end

function *(x::Interval, y::Interval)
    T = promote_type(typeof(x.a), typeof(x.b))
    if 0 in x || 0 in y
        error("Multiplying with intervals containing 0 not supported.")
    end
    a = setrounding(T, RoundDown) do
        # TODO: lower bound
        ## SOLUTION
        if x.a < 0 && x.b < 0 && y.a < 0 && y.b < 0
            y.b * x.b
        elseif x.a < 0 && x.b < 0 && y.a > 0 && y.b > 0
            x.a * y.b
        elseif x.a > 0 && x.b > 0 && y.a < 0 && y.b < 0
            x.b * y.a
        else
            x.a * y.a
        end
        ## END
    end
    b = setrounding(T, RoundUp) do
        # TODO: upper bound
        ## SOLUTION
        if x.a < 0 && x.b < 0 && y.a < 0 && y.b < 0
            y.a * x.a
        elseif x.a < 0 && x.b < 0 && y.a > 0 && y.b > 0
            x.b * y.a
        elseif x.a > 0 && x.b > 0 && y.a < 0 && y.b < 0
            x.a * y.b
        else
            x.b * y.b
        end
        ## END
    end
    Interval(a, b)
end

function +(x::Interval, y::Interval)
    T = promote_type(typeof(x.a), typeof(x.b))
    a = setrounding(T, RoundDown) do
        # TODO: upper bound
        ## SOLUTION
        x.a + y.a
        ## END
    end
    b = setrounding(T, RoundUp) do
        # TODO: upper bound
        ## SOLUTION
        x.b + y.b
        ## END
    end
    Interval(a, b)
end
```

**Problem 5.4** Bound the tail of the Taylor series for ${\rm e}^x$ assuming $|x| \leq 1$. 
(Hint: ${\rm e}^x \leq 3$ for $x \leq 1$.)
Use the bound
to complete the function `exp_bound` which computes ${\rm e}^x$ with rigorous error bounds, that is
so that when applied to an interval $[a,b]$ it returns an interval that is 
guaranteed to contain the interval $[{\rm e}^a, {\rm e}^b]$.

```julia
function exp_bound(x::Interval, n)
    if abs(x.a) > 1 || abs(x.b) > 1
        error("Interval must be a subset of [-1, 1]")
    end
    ret = exp_t(x, n) # the code for Taylor series should work on Interval unmodified
    f = factorial(min(20, n + 1)) # avoid overflow in computing factorial
    T = typeof(ret.a)

    # TODO: modify ret so that exp(x) is guaranteed to lie in it
    ## SOLUTION
    err = setrounding(T, RoundUp) do
        3 / f
    end
    ret + Interval(-err,err)
    ## END
end
```

Check your result by assuring that
the following returns true:
```julia
exp(big(1)) in exp_bound(Interval(1.0,1.0), 20) && exp(big(-1)) in exp_bound(Interval(-1.0,-1.0), 20)
```

**SOLUTION** From the Taylor remainder theorem we know the error is
$$
{f^{(k+1)}(ξ) \over (k+1)!} |x|^{k+1} \leq {3 \over (k+1)!}
$$
Thus by widening the computation by this error we ensure that we have
captured the error by truncating the Taylor series.

